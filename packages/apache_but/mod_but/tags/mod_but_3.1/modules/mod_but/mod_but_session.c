/*#############################################
#
# Title:        mod_but_session.c
# Author:       e1@but.ch
# Date:         November 21, 2006
# Version:      2.9
#
#############################################*/

#include "mod_but.h"

int create_new_mod_but_session(request_rec *r)
{

  /*
   * a) Generate new Session ID
   * b) Copies the Session as Set-Cookie into the response header field
   * c) Creates the required structures in the shared memory segment
   *
   * 	PLEASE NOTE, THIS FUNCTION IS FOR THE FIRST LOGIN AND SET HEADER VIA R->ERR_HEADERS_OUT
   *
   */

  int shmoffset = 0;
  mod_but_server_t *config = ap_get_module_config(r->server->module_config, &but_module);
  unsigned char *sid = apr_pcalloc(r->pool, 64);
  ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: CREATE NEW MOD_BUT_SESSION");

  if(sid)
  {
	const char *cookie;
	const char *cookiename;
	const char *domain;
	const char *path;
	const char *secure;
	const char *httponly;
	const char *expiration;
	int i, c;
	if(apr_generate_random_bytes(sid, 63) == APR_SUCCESS)
	{
	/*
	* Convert the generated bytes to be within the alphanumeric
	* range.  This reduces the randomness by about half, but that's
	* OK for our purposes.
	*
	*/
	ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: ======== SID CREATED BY apr_generate_random_byte");

	for(i = 0;i < 63;i++)
	{
		c = abs(sid[i]) % 62;

		if(c < 10)
		sid[i] = c + 48;
		else if(c < 36)
		sid[i] = c + 55;
		else
		sid[i] = c + 61;
	}
	/*
		Create a new "session" into the shared memory segment
	*/
	ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: =============== SID CREATED");
	cleaning_shm_from_expired_session(r);
	cleaning_shm_history_from_expired_session(r);

	shmoffset = create_new_shm_session(r, sid);
	if (shmoffset == 1000)
	{
		ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: Unable creating an new SHM session");
		return -1;
	}

	ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: CREATE NEW SESSION [%s]", sid);
	ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: CREATE SESSION AT SHM [%d]", shmoffset);

	cookie = NULL;
	cookiename = config->cookie_name;

	if (!apr_strnatcmp(config->cookie_domain, "")) {
                domain = apr_psprintf(r->pool, "%s", "");
        } else {
                domain = apr_psprintf(r->pool, "domain=%s; ", config->cookie_domain);
        }


	if (!apr_strnatcmp(config->cookie_path, "")) {
                path = apr_psprintf(r->pool, "%s", "");
        } else {
                path = apr_psprintf(r->pool, "path=%s; ", config->cookie_path);
        }


	if (config->cookie_secure == 1) {
                secure = apr_psprintf(r->pool, "%s", "secure; ");
        } else {
                secure = apr_psprintf(r->pool, "%s", "");
        }


	if (config->cookie_httponly == 1) {
                httponly = apr_psprintf(r->pool, "%s", "HttpOnly");
        } else {
                httponly = apr_psprintf(r->pool, "%s", "");
        }


	if (!apr_strnatcmp(config->cookie_expiration, "")) {
                expiration = apr_psprintf(r->pool, "%s", "");
        } else {
                expiration = apr_psprintf(r->pool, "expires=%s; ", config->cookie_expiration);
        }


	cookie = (char *)apr_psprintf(r->pool, "%s=%s; %s%s%s%s%s", cookiename, sid, domain, path, expiration, secure, httponly );
	ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: SET-COOKIE STRING [%s]", cookie);

	/*
		Here for the "normal" login process
	*/
	apr_table_setn(r->err_headers_out, "Set-Cookie" , cookie );
	ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: SET-COOKIE: [%s]", apr_table_get(r->headers_out, "Set-Cookie"));
	return shmoffset;

	}else{
	sid = NULL;
	return -2;
     }
  }
  return OK;
}

int create_new_mod_but_session_renew(request_rec *r)
{

  /*
   * a) Generate new Session ID
   * b) Copies the Session as Set-Cookie into the response header field
   * c) Creates the required structures in the shared memory segment
   *
   *   PLEASE NOTE - THIS FUNCTION RETURNS HEADER VIA R->HEADERS_OUT
   *
   */

  int shmoffset = 0;
  mod_but_server_t *config = ap_get_module_config(r->server->module_config, &but_module);
  unsigned char *sid = apr_pcalloc(r->pool, 64);
  ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: SESSION MANAGEMENT: CREATE NEW MOD_BUT_SESSION");

  if(sid)
  {
	const char *cookie;
	const char *cookiename;
	const char *domain;
	const char *path;
	const char *secure;
	const char *httponly;
	const char *expiration;
	if(apr_generate_random_bytes(sid, 63) == APR_SUCCESS)
	{
	/*
	* Convert the generated bytes to be within the alphanumeric
	* range.  This reduces the randomness by about half, but that's
	* OK for our purposes.
	*
	*/

	int i, c;

	for(i = 0;i < 63;i++)
	{
		c = abs(sid[i]) % 62;

		if(c < 10)
		sid[i] = c + 48;
		else if(c < 36)
		sid[i] = c + 55;
		else
		sid[i] = c + 61;
	}
	/*
		Create a new "session" into the shared memory segment
	*/
	cleaning_shm_from_expired_session(r);
	cleaning_shm_history_from_expired_session(r);

	shmoffset = create_new_shm_session(r, sid);
	if (shmoffset == 1000)
	{
		ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: Unable creating an new SHM session");
		return -1;
	}

	ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: CREATE NEW SESSION [%s]", sid);
	ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: SESSION MANAGEMENT: NEW CS OFFSET [%d]", shmoffset);

	cookie = NULL;

	cookiename = config->cookie_name;

	if (!apr_strnatcmp(config->cookie_domain, "")) {
                domain = apr_psprintf(r->pool, "%s", "");
        } else {
                domain = apr_psprintf(r->pool, "domain=%s; ", config->cookie_domain);
        }


	if (!apr_strnatcmp(config->cookie_path, "")) {
                path = apr_psprintf(r->pool, "%s", "");
        } else {
                path = apr_psprintf(r->pool, "path=%s; ", config->cookie_path);
        }


	if (config->cookie_secure == 1) {
                secure = apr_psprintf(r->pool, "%s", "secure; ");
        } else {
                secure = apr_psprintf(r->pool, "%s", "");
        }


	if (config->cookie_httponly == 1) {
                httponly = apr_psprintf(r->pool, "%s", "HttpOnly");
        } else {
                httponly = apr_psprintf(r->pool, "%s", "");
        }


	if (!apr_strnatcmp(config->cookie_expiration, "")) {
                expiration = apr_psprintf(r->pool, "%s", "");
        } else {
                expiration = apr_psprintf(r->pool, "expires=%s; ", config->cookie_expiration);
        }


	cookie = (char *)apr_psprintf(r->pool, "%s=%s; %s%s%s%s%s", cookiename, sid, domain, path, expiration, secure, httponly );
	ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: SET-COOKIE STRING [%s]", cookie);

	/*
		Here for the renew process
	*/
	apr_table_setn(r->headers_out, "Set-Cookie" , cookie );
	ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: SET-COOKIE: [%s]", apr_table_get(r->headers_out, "Set-Cookie"));
	return shmoffset;

	}else{
	sid = NULL;
	return -2;
     }
  }
  return OK;
}


/*
	Function returns integer value (shmoffset), if the session is found in the shm section

*/
int validation_of_client_sent_session(request_rec *r)
{
	int i;
	int y=0;
	mod_but_server_t *config = ap_get_module_config(r->server->module_config, &but_module);
	apr_rmm_t *cs_rmm = find_cs_rmm();

	apr_rmm_off_t *off = find_cs_rmm_off();

	apr_rmm_t *cs_rmm_history = find_cs_rmm_history();
	apr_rmm_off_t *off_history = find_cs_rmm_off_history();

	/*

		Cleanup Function (delete *old* sessions from shm)

	*/


	for (i = 0; i < MOD_BUT_SESSION_COUNT; i++) {

		/*
			Lets go through the shm to find out, if the session is in our shm store

		*/
		mod_but_cookie *c = apr_rmm_addr_get(cs_rmm, off[i]);
		//ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: VALIDATE SESSION [%s] AT SHM [%d]", c->session_value, i);

		if (!apr_strnatcmp(c->session_value, apr_table_get(r->notes, config->cookie_name)))
		{
			apr_time_t curtime;
			int tnow;
			int tcreate;
			int tlastaccess;

			/*
				If we are here, the client has sent a MOD_BUT_SESSION

			*/
			ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: FOUND SESSION AT SHM [%d]", i);
			curtime = apr_time_now();
			tnow = (int)apr_time_sec(curtime);
			tcreate = c->session_create_time;
			tlastaccess = c->session_last_access_time;

			if ((tnow - tcreate) > config->session_timeout){
				// In this case, the sent session has reached its time out
				ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: Delta between tnow and tcreate %d", tnow-tcreate);
				ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: DELETING - SESSION TIMOUT REACHED AT SHM [%d]", i);
				delete_mod_but_session(i, r);
				return -5540;
			}

			if ( (tnow - tlastaccess) > config->session_inactivity_timeout){
				// In this case, the sent session has reached its inactivity timeout
				ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: Delta between tnow and tlastaccess %d", tnow-tlastaccess);
				ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: DELETING - INACTIVITY TIMOUT REACHED AT SHM [%d]", i);
				delete_mod_but_session(i, r);
				return -5541;
			} else{
				ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: Updating last access time");
				ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: Delta between tnow and tlastaccess %d", tnow-tlastaccess);
				ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: UPDATING MAC OF SESSION AT SHM [%d]", i);
				c->session_last_access_time = tnow;
			}

			// if we are here, the session is valid, and not timed out yet, so we return the shmoffset
			ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: SHM [%d] IS OK", i);
			return i;
        	}
	}

	// In this case, the sent session by the client is invalid, guessed, hacked or in the history


	for (y = 0; y < MOD_BUT_SESSION_HISTORY_COUNT; y++) {
		mod_but_cookie_history *c_history = apr_rmm_addr_get(cs_rmm_history, off_history[y]);

		if (!apr_strnatcmp(c_history->session_value, apr_table_get(r->notes, config->cookie_name)))
		{
			ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: Client Session found in SHM HISTORY %s", c_history->session_value);
			return -5542;
		}
	}

	/*
		If we are here, the session is not in the normal SHM or in the History SHM. It must be a tamper attempt
	*/
	ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: HACKING ATTEMPT %s", apr_table_get(r->notes, config->cookie_name));
	return -5543;
}


/*
	Delete session in session shm store
	Delete everything in history shm store
	Delete everything in cookie shm store

*/
int delete_mod_but_session(apr_int64_t shmoff, request_rec *r){

	int i;

	apr_rmm_t *cs_rmm = find_cs_rmm();
	apr_rmm_off_t *off = find_cs_rmm_off();
	apr_rmm_t *cs_rmm_history = find_cs_rmm_history();
	apr_rmm_off_t *off_history = find_cs_rmm_off_history();

	mod_but_cookie *c = apr_rmm_addr_get(cs_rmm, off[shmoff]);



	for (i = 0; i < MOD_BUT_SESSION_HISTORY_COUNT; i++) {
        	mod_but_cookie_history *c_history = apr_rmm_addr_get(cs_rmm_history, off_history[i]);

		/*
			Searching an empty place in the history shm store and copy the session_value to the history

		*/
		if (!apr_strnatcmp(c_history->session_value, "empty"))
		{

			/*
				If we are here, we have found an empty history shm place and backup
				the deleting session into the history store

			*/
			apr_cpystrn(c_history->session_value, c->session_value, sizeof(c_history->session_value));
			c_history->session_delete_time = (int)apr_time_sec(apr_time_now());

			ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: Make history of session %s at history SHM offset %d", c_history->session_value, i);

			/*
				Now we have a backup of the session value in the history.
				The next step will delete the session in the session shm store to make it free for others

			*/
			apr_cpystrn(c->session_name, "empty", sizeof(c->session_name));
			apr_cpystrn(c->session_value, "empty", sizeof(c->session_value));
			apr_cpystrn(c->session_firsturl, "empty", sizeof(c->session_firsturl));
			c->logon_state = 0;
			c->logon_flag = 0;
			c->auth_strength = 0;
			apr_cpystrn(c->orig_url_before_logon, "empty", sizeof(c->orig_url_before_logon));
			apr_cpystrn(c->service_list, "empty", sizeof(c->service_list));


			if (c->link_to_cookiestore == -1){
				ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: There is nothing in the cookie store to delete");
			}else{
				ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: Start DELETING cookiestore headers at CS offset %d", c->link_to_cookiestore);
				delete_cookiestore_entries_belonging_to_a_deleting_session(r, c->link_to_cookiestore);
			}
			return OK;
		}
	}

	/*
		If we are here, there was no space left in the SHM history. This is a PROBLEM.
		We will delete the session without doing history, but we have at least a log entry

	*/
	apr_table_setn(r->notes, "HISTORY_SHM" , "PROBLEM");
	ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: (SHM HISTORY) All SHM HISTORY is used - Unable to make history of session");

	apr_cpystrn(c->session_name, "empty", sizeof(c->session_name));
	apr_cpystrn(c->session_value, "empty", sizeof(c->session_value));
	apr_cpystrn(c->session_firsturl, "empty", sizeof(c->session_firsturl));

	if (c->link_to_cookiestore == -1){
		ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: There is nothing in the cookie store to delete");
	}else{
		ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: Start DELETING cookiestore headers at CS offset %d", c->link_to_cookiestore);
		delete_cookiestore_entries_belonging_to_a_deleting_session(r, c->link_to_cookiestore);
	}
	return OK;
}


int renew_mod_but_session(apr_int64_t shmoffold, request_rec *r){

	apr_rmm_t *cs_rmm = find_cs_rmm();
	apr_rmm_off_t *off = find_cs_rmm_off();
	int shmoffset = 0;
	int ret;
	mod_but_server_t *config;
	mod_but_cookie *c_old;
	mod_but_cookie *c_new;

	ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: SESSION MANAGEMENT: RENEW SESSION");

	ret = HTTP_MOVED_TEMPORARILY;
	config = ap_get_module_config(r->server->module_config, &but_module);
	c_old = apr_rmm_addr_get(cs_rmm, off[shmoffold]);

	/*
		The function below will set headers via r->headers_out
	*/
	shmoffset = create_new_mod_but_session_renew(r);

	if (shmoffset == -1)
	{
		ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: Problems with SHM Creation, DECLINED");
		apr_table_setn(r->err_headers_out, "Location", config->all_shm_space_used_url);
		r->content_type = NULL;
		return(ret);
	}

	if (shmoffset == -2)
	{
		ap_log_rerror(PC_LOG_INFO, r, "mod_but_sessions.c: Problems with SID Creation, DECLINED");
		return -2;
	}

	c_new = apr_rmm_addr_get(cs_rmm, off[shmoffset]);
	c_new->session_create_time = c_old->session_create_time;
	c_new->session_last_access_time = c_old->session_last_access_time;
	c_new->link_to_cookiestore = c_old->link_to_cookiestore;
	c_new->logon_state = c_old->logon_state;
	c_new->logon_flag = c_old->logon_flag;
	c_new->auth_strength = c_old->auth_strength;
	apr_cpystrn(c_new->orig_url_before_logon, c_old->orig_url_before_logon, sizeof(c_new->orig_url_before_logon));
	apr_cpystrn(c_new->service_list, c_old->service_list, sizeof(c_new->service_list));
	c_old->link_to_cookiestore =-1;

	// if everything is copied from the old to the new session, let's delete the old stuff
	delete_mod_but_session(shmoffold, r);

	return shmoffset;

}





